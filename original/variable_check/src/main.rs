fn main() {
    // メモリの整理
    example1();

    // シャードーイングの整理
    example2();

    // copy(Copyトレイト)とmove(Dropトレイト)の整理
    example3();
}

fn example1() {
    // スカラ型
    // スタックに入る
    let _i = 1234;
    let _c = 'c';
    let _b = true;

    // &str型
    // 静的領域(.rdataセクションなど)に入る
    // スタックには静的領域への参照が入る
    let _str = "hogehoge";

    // String型
    // "mogemoge"は静的領域
    // fromでインスタンス化されたときにヒープに作成
    // スタックにはヒープへの参照が入る
    let _string = String::from("mogemoge");

    // タプル型
    // 1234 : スタック
    // 'c' : スタック
    // "hoge" : 静的領域(.rdataセクションなど)
    // "hello world!" : の初期値は静的領域。fromでインスタンス化されたときにヒープに作成
    // サイズやインデックスなどはコンパイル時に直接コード内に埋め込まれる
    let _tup = (1234, 'c', "hoge", String::from("hello world!"));

    // 配列型
    // 文字列は静的領域
    // サイズやインデックスなどはコンパイル時に直接コード内に埋め込まれる
    let _array: [&str; 3] = ["January", "February", "March"];
}

fn example2() {
    // 当然エラー
    // let i: i8 = 3;
    // i = "hoge";
    
    // シャドーイング(通常)
    // 最初のi(i8)は次のi(&str)により覆い隠されれる。
    // 最初のiは、コンパイラは最初のiを認識しているものの、コード上ではアクセスできなくなる。
    let i: i8 = 3;
    println!("{}", i); // => 3

    let i: &str = "hoge";
    println!("{}", i); // => hoge。もうプログラム上、3にはアクセスする術がない。

    // シャドーイング(アクセスできる方法)
    // シャドーイングにより元の変数が変更されているわけではなく、
    // 新たにメモリ上の別領域に変数名と値が作られている。
    // => 元のものはそのまま残っている。
    let x: i8 = 3;
    let y = &x; // 借用しておく
    let x = "hoge"; // シャドーイング
    println!("{}", x);
    println!("{}", y);
}

fn example3() {
    let x = 8;
    let y = 12;

    // スタックの状況
    //
    // --- TOP ------
    // y = 12
    // --------------
    // x = 8
    // --- BOTTOM ---

    // 以下スタックに格納されたアドレスを直接参照。
    // LIFOのポップではない。
    println!("{}", x);
    println!("{}", y);

    let z = &y;

    // スタックの状況
    //
    // --- TOP ------
    // z = yへの参照
    // --------------
    // y = 12
    // --------------
    // x = 8
    // --- BOTTOM ---

    println!("{}", z);

    // Copyトレイトのメモリ状況(スカラ型のみ)
    let a = x;
    println!("{},{}", a, x);

    // スタックの状況
    //
    // --- TOP -------------------------
    // a = 8 (xの値のハードコピー)
    // ---------------------------------
    // z = yへの参照
    // ---------------------------------
    // y = 12
    // ---------------------------------
    // x = 8 (copyなので残り続ける)
    // --- BOTTOM ----------------------

    // moveのメモリ状況(heep)
    let s1 = String::from("a");
                 
    // スタックの状況
    //
    // --- TOP --------------------------------
    // s1 = "a" への参照(heepのポインタ、長さ)
    // ----------------------------------------
    // a = 8 (xの値のハードコピー)
    // ----------------------------------------
    // z = yへの参照
    // ----------------------------------------
    // y = 12
    // ----------------------------------------
    // x = 8 (copyなので残り続ける)
    // --- BOTTOM -----------------------------
    
    // moveのメモリ状況(heep)
    let s2 = s1; // move

    // スタックの状況
    //
    // --- TOP --------------------------------
    // s2 = "a" への参照(heepのポインタ、長さ)
    // ----------------------------------------
    // s1 残るが参照が消され,アクセルすると
    // コンパイルエラー
    // ----------------------------------------
    // a = 8 (xの値のハードコピー)
    // ----------------------------------------
    // z = yへの参照
    // ----------------------------------------
    // y = 12
    // ----------------------------------------
    // x = 8 (copyなので残り続ける)
    // --- BOTTOM -----------------------------
}
